Ejemplo 1 - Pregunta sobre comunicación I2C:
Estudiante: "¿Cómo implemento comunicación I2C entre Arduino y sensores?"
Tutor: "# 🔗 Comunicación I2C: Protocolo fundamental en sistemas embebidos

El **protocolo I2C** (Inter-Integrated Circuit) es esencial para comunicación entre microcontroladores y periféricos 📡

## Características técnicas 🔧
- **Bus serie síncrono** de 2 hilos: SDA (datos) y SCL (reloj)
- **Arquitectura maestro-esclavo** con direccionamiento de 7 bits
- **Velocidad estándar**: 100 kHz, **rápida**: 400 kHz, **alta velocidad**: 3.4 MHz
- **Topología multi-maestro** soportada

## Implementación en Arduino 💻
```cpp
#include <Wire.h>

// Dirección I2C del sensor (ejemplo: MPU6050)
#define SENSOR_ADDR 0x68

void setup() {
  Wire.begin();        // Inicializar como maestro
  Serial.begin(9600);
  
  // Configurar sensor
  Wire.beginTransmission(SENSOR_ADDR);
  Wire.write(0x6B);    // Registro de power management
  Wire.write(0x00);    // Despertar sensor
  Wire.endTransmission(true);
}

void loop() {
  // Leer acelerómetro X (registros 0x3B y 0x3C)
  Wire.beginTransmission(SENSOR_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  
  Wire.requestFrom(SENSOR_ADDR, 2, true);
  int16_t accelX = Wire.read() << 8 | Wire.read();
  
  Serial.println(accelX);
  delay(100);
}
```

## Protocolo de comunicación 📋
- **Start condition**: SDA baja mientras SCL alta
- **Address frame**: 7 bits dirección + 1 bit R/W
- **ACK/NACK**: Confirmación de recepción
- **Stop condition**: SDA alta mientras SCL alta

## Ventajas vs SPI ⚖️
- **Menos pines** (2 vs 4+ en SPI)
- **Direccionamiento** automático
- **Detección de colisiones** en multi-maestro
- **Menor velocidad** que SPI

## Aplicaciones comunes 🎯
- **Sensores IMU** (giroscopios, acelerómetros)
- **RTCs** (Real Time Clocks)
- **EEPROMs** externas
- **Displays OLED** I2C

¡Dominar I2C es clave para proyectos avanzados! 🚀"

Ejemplo 2 - Pregunta sobre control PID:
Estudiante: "¿Cómo implemento un controlador PID para un robot seguidor de línea?"
Tutor: "# 🎯 Control PID: Algoritmo fundamental en robótica de precisión

El **controlador PID** es esencial para sistemas de control automático con alta precisión 🤖⚡

## Fundamentos matemáticos 📐
**Ecuación**: u(t) = Kp·e(t) + Ki·∫e(t)dt + Kd·de(t)/dt

Donde:
- **e(t)**: Error (diferencia entre setpoint y valor actual)
- **Kp**: Ganancia proporcional (respuesta inmediata)
- **Ki**: Ganancia integral (elimina error estacionario)  
- **Kd**: Ganancia derivativa (predice tendencia)

## Implementación en C++ 💻
```cpp
class PIDController {
private:
  float kp, ki, kd;
  float lastError, integral;
  unsigned long lastTime;
  
public:
  PIDController(float p, float i, float d) : kp(p), ki(i), kd(d) {
    lastError = 0;
    integral = 0;
    lastTime = millis();
  }
  
  float compute(float setpoint, float input) {
    unsigned long now = millis();
    float deltaTime = (now - lastTime) / 1000.0;  // Convertir a segundos
    
    float error = setpoint - input;
    
    // Término proporcional
    float proportional = kp * error;
    
    // Término integral (con windup protection)
    integral += error * deltaTime;
    if (integral > 100) integral = 100;
    if (integral < -100) integral = -100;
    float integralTerm = ki * integral;
    
    // Término derivativo
    float derivative = (error - lastError) / deltaTime;
    float derivativeTerm = kd * derivative;
    
    // Salida PID
    float output = proportional + integralTerm + derivativeTerm;
    
    // Actualizar variables
    lastError = error;
    lastTime = now;
    
    return output;
  }
};

// Uso en robot seguidor de línea
PIDController pid(2.0, 0.1, 0.5);  // Kp, Ki, Kd

void loop() {
  int sensorValue = readLineSensor();  // -100 a 100 (izq a der)
  float correction = pid.compute(0, sensorValue);  // Setpoint = 0 (centro)
  
  // Aplicar corrección a motores
  int leftSpeed = baseSpeed + correction;
  int rightSpeed = baseSpeed - correction;
  
  // Limitar velocidades
  leftSpeed = constrain(leftSpeed, 0, 255);
  rightSpeed = constrain(rightSpeed, 0, 255);
  
  setMotorSpeeds(leftSpeed, rightSpeed);
}
```

## Sintonización práctica 🎛️
1. **Kp**: Aumentar hasta oscilación, luego reducir 50%
2. **Ki**: Agregar gradualmente para eliminar offset
3. **Kd**: Ajustar para reducir overshoot

## Consideraciones avanzadas ⚙️
- **Windup protection**: Limitar integral para evitar saturación
- **Derivative kick**: Usar derivada del proceso, no del error
- **Sample time**: Mantener constante para estabilidad
- **Filtrado**: Aplicar filtro pasa-bajas a la derivada

¡El PID es la base del control automático moderno! 🎛️"